use parrot_api::actor::{Actor, ActorConfig, ActorState, EmptyConfig};
use parrot_api::message::Message;
use parrot_api::types::{BoxedMessage, ActorResult, BoxedFuture};
use parrot_api::errors::ActorError;
use parrot_api_derive::{Message, ParrotActor};
use parrot_api::{match_message, message_response_ok};

use std::fmt::Debug;
use std::any::Any;
use std::ptr::NonNull;

// Constants for engine selection
pub const ACTIX: &str = "actix";
pub const TOKIO: &str = "tokio";

// Create a mock module to mimic parrot::actix module
pub mod parrot {
    pub mod actix {
        // Mock ActixContext for testing
        pub struct ActixContext<A = ()> {
            _phantom: std::marker::PhantomData<A>,
        }
        
        impl<A> Default for ActixContext<A> {
            fn default() -> Self {
                ActixContext {
                    _phantom: std::marker::PhantomData,
                }
            }
        }
        
        // Add missing ActixActor type that's expected by the macro
        pub struct ActixActor<A> {
            _phantom: std::marker::PhantomData<A>,
        }
        
        impl<A> Default for ActixActor<A> {
            fn default() -> Self {
                ActixActor {
                    _phantom: std::marker::PhantomData,
                }
            }
        }
        
        // Mock ActorBase for testing
        pub struct ActorBase<A> {
            actor: A,
        }
        
        impl<A> ActorBase<A> {
            pub fn new(actor: A) -> Self {
                ActorBase { actor }
            }
        }
        
        // Mock trait for testing
        pub trait IntoActorBase {
            fn into_actor_base(self) -> ActorBase<Self> where Self: Sized;
        }
    }
}

// Custom configuration type
#[derive(Debug, Default)]
pub struct MyConfig {
    pub timeout: u64,
}
impl ActorConfig for MyConfig {}

// Define messages for testing
#[derive(Message, Clone, Debug)]
#[message(result = "u32")]
pub struct Increment(pub u32);

#[derive(Message, Clone, Debug)]
#[message(result = "String")]
pub struct GetStatus;

#[derive(Message, Clone, Debug)]
#[message(result = "()")]
pub struct Reset;

// For testing unknown message types
#[derive(Clone, Debug)]
pub struct UnknownMessage;

// Test multiple return types
#[derive(Message, Clone, Debug)]
#[message(result = "Result<String, String>")]
pub struct ComplexMessage {
    pub succeed: bool,
    pub data: String,
}

// Simple counter message from simplified test
#[derive(Message, Clone, Debug)]
#[message(result = "u32")]
pub struct CounterMsg(pub u32);

// Additional messages for engine testing
#[derive(Message, Clone, Debug)]
#[message(result = "u64")]
pub struct Multiply(pub u32);

#[derive(Message, Clone, Debug)]
#[message(result = "u64")]
pub struct GetEngineCounter;

#[derive(Message, Clone, Debug)]
#[message(result = "u32")]
pub struct SetMode(pub u32);

#[derive(Message, Clone, Debug)]
#[message(result = "String")]
pub struct InvalidOperation;

// Different operation modes
#[derive(Debug, PartialEq)]
pub enum EngineMode {
    Normal = 0,
    ReadOnly = 1,
    ErrorProne = 2,
}

impl From<u32> for EngineMode {
    fn from(value: u32) -> Self {
        match value {
            1 => EngineMode::ReadOnly,
            2 => EngineMode::ErrorProne,
            _ => EngineMode::Normal,
        }
    }
}

// Engine context for testing
#[derive(Debug)]
pub struct TestEngineContext {
    pub multiplier: u32,
    pub mode: EngineMode,
}

// ==================== Actor Implementations ====================

// 1. Using default engine (actix), explicitly specifying EmptyConfig
#[derive(ParrotActor, Debug)]
#[ParrotActor(engine = "actix")]
pub struct DefaultActor {
    counter: u32,
}

// Add handle_message method to support code generated by ParrotActor macro
impl DefaultActor {

    pub async fn handle_message(&mut self, msg: BoxedMessage, _ctx: &mut parrot::actix::ActixContext<parrot::actix::ActixActor<Self>>) 
        -> ActorResult<BoxedMessage> {
        match_message!(self, msg,
            Increment => |actor: &mut Self, inc: &Increment| {
                actor.counter += inc.0;
                actor.counter
            },
            GetStatus => |_: &mut Self, _: &GetStatus| {
                "default".to_string()
            },
            Reset => |actor: &mut Self, _: &Reset| {
                actor.counter = 0;
                ()
            },
            ComplexMessage => |_: &mut Self, complex: &ComplexMessage| {
                if complex.succeed {
                    Ok::<String, String>(complex.data.clone())
                } else {
                    Err::<String, String>("Failed operation".to_string())
                }
            }
        )
    }

    pub fn handle_message_engine(&mut self, _msg: BoxedMessage, _ctx: &mut parrot::actix::ActixContext<parrot::actix::ActixActor<Self>>, _engine_ctx: NonNull<dyn Any>) -> Option<ActorResult<BoxedMessage>> {
        None
    }

}

// 2. Using string to specify engine
#[derive(ParrotActor, Debug)]
#[ParrotActor(engine = "actix")]
pub struct StringEngineActor {
    counter: u32,
}

// Add handle_message method
impl StringEngineActor {
    pub async fn handle_message(&mut self, msg: BoxedMessage, _ctx: &mut parrot::actix::ActixContext<parrot::actix::ActixActor<Self>>) 
        -> ActorResult<BoxedMessage> {
        if let Some(increment) = msg.downcast_ref::<Increment>() {
            self.counter += increment.0;
            return message_response_ok!(Increment, self.counter);
        }
        
        if let Some(_) = msg.downcast_ref::<GetStatus>() {
            return message_response_ok!(GetStatus, "string_engine".to_string());
        }
        
        Err(ActorError::MessageHandlingError("Unknown message type".to_string()))
    }
    
    pub fn handle_message_engine(&mut self, _msg: BoxedMessage, _ctx: &mut parrot::actix::ActixContext<parrot::actix::ActixActor<Self>>, _engine_ctx: NonNull<dyn Any>) -> Option<ActorResult<BoxedMessage>> {
        None
    }
}

// 3. Using constant to specify engine
#[derive(ParrotActor, Debug)]
#[ParrotActor(engine = "actix")]
pub struct ConstantEngineActor {
    counter: u32,
}

// Add handle_message method
impl ConstantEngineActor {
    pub async fn handle_message(&mut self, msg: BoxedMessage, _ctx: &mut parrot::actix::ActixContext<parrot::actix::ActixActor<Self>>) 
        -> ActorResult<BoxedMessage> {
        if let Some(increment) = msg.downcast_ref::<Increment>() {
            self.counter += increment.0;
            return Ok(Box::new(self.counter) as Box<dyn Any + Send>);
        }
        
        if let Some(_) = msg.downcast_ref::<GetStatus>() {
            return Ok(Box::new("constant_engine".to_string()) as Box<dyn Any + Send>);
        }
        
        Err(ActorError::MessageHandlingError("Unknown message type".to_string()))
    }
    
    pub fn handle_message_engine(&mut self, _msg: BoxedMessage, _ctx: &mut parrot::actix::ActixContext<parrot::actix::ActixActor<Self>>, _engine_ctx: NonNull<dyn Any>) -> Option<ActorResult<BoxedMessage>> {
        None
    }
}

// 4. Using full configuration parameters, specifying MyConfig as configuration type
#[derive(ParrotActor, Debug)]
#[ParrotActor(engine = "actix", config = "MyConfig")]
pub struct ComplexConfigActor {
    counter: u32,
    config: MyConfig,
}

// Add handle_message method
impl ComplexConfigActor {
    pub async fn handle_message(&mut self, msg: BoxedMessage, _ctx: &mut parrot::actix::ActixContext<parrot::actix::ActixActor<Self>>) 
        -> ActorResult<BoxedMessage> {
        if let Some(increment) = msg.downcast_ref::<Increment>() {
            self.counter += increment.0;
            return Ok(Box::new(self.counter) as Box<dyn Any + Send>);
        }
        
        if let Some(_) = msg.downcast_ref::<GetStatus>() {
            return Ok(Box::new(self.config.timeout.to_string()) as Box<dyn Any + Send>);
        }
        
        Err(ActorError::MessageHandlingError("Unknown message type".to_string()))
    }
    
    pub fn handle_message_engine(&mut self, _msg: BoxedMessage, _ctx: &mut parrot::actix::ActixContext<parrot::actix::ActixActor<Self>>, _engine_ctx: NonNull<dyn Any>) -> Option<ActorResult<BoxedMessage>> {
        None
    }
}

// 5. Simple actor from simplified test
#[derive(ParrotActor, Debug)]
#[ParrotActor(engine = "actix", config = "parrot_api::actor::EmptyConfig")]
pub struct SimpleActor {
    counter: u32,
}

impl SimpleActor {
    pub fn new() -> Self {
        SimpleActor { counter: 0 }
    }
    
    // Handler for ParrotActor macro
    pub async fn handle_message(&mut self, msg: BoxedMessage, _ctx: &mut parrot::actix::ActixContext<parrot::actix::ActixActor<Self>>) 
        -> ActorResult<BoxedMessage> {
        if let Some(counter_msg) = msg.downcast_ref::<CounterMsg>() {
            self.counter += counter_msg.0;
            return Ok(Box::new(self.counter) as Box<dyn Any + Send>);
        }
        
        Err(ActorError::MessageHandlingError("Unknown message".to_string()))
    }
    
    pub fn handle_message_engine(&mut self, _msg: BoxedMessage, _ctx: &mut parrot::actix::ActixContext<parrot::actix::ActixActor<Self>>, _engine_ctx: NonNull<dyn Any>) -> Option<ActorResult<BoxedMessage>> {
        None
    }
}

// 6. Testing multi-level nested generic types
#[derive(ParrotActor, Debug)]
#[ParrotActor(engine = "actix", config = "parrot_api::actor::EmptyConfig")]
pub struct GenericActor<T: Debug + Clone + Send + 'static> {
    value: T,
}

// Add handle_message method
impl<T: Debug + Clone + Send + 'static> GenericActor<T> {
    pub async fn handle_message(&mut self, msg: BoxedMessage, _ctx: &mut parrot::actix::ActixContext<parrot::actix::ActixActor<Self>>) 
        -> ActorResult<BoxedMessage> {
        if let Some(increment) = msg.downcast_ref::<Increment>() {
            // Special handling based on T's type
            // If T is Vec<i32>, add a new element
            if let Some(vec) = ((&self.value) as &dyn Any).downcast_ref::<Vec<i32>>() {
                let mut new_vec = vec.clone();
                new_vec.push(increment.0 as i32);
                // Update self.value
                if let Some(value_any) = (Box::new(new_vec.clone()) as Box<dyn Any>).downcast::<T>().ok() {
                    self.value = *value_any;
                }
                return Ok(Box::new(new_vec) as Box<dyn Any + Send>);
            }
            // Otherwise just return a clone of the value
            return Ok(Box::new(self.value.clone()) as Box<dyn Any + Send>);
        }
        
        if let Some(_) = msg.downcast_ref::<GetStatus>() {
            return Ok(Box::new(format!("{:?}", self.value)) as Box<dyn Any + Send>);
        }
        
        if let Some(_) = msg.downcast_ref::<Reset>() {
            return Ok(Box::new("reset") as Box<dyn Any + Send>);
        }
        
        Err(ActorError::MessageHandlingError("Unknown message type".to_string()))
    }
    
    pub fn handle_message_engine(&mut self, _msg: BoxedMessage, _ctx: &mut parrot::actix::ActixContext<parrot::actix::ActixActor<Self>>, _engine_ctx: NonNull<dyn Any>) -> Option<ActorResult<BoxedMessage>> {
        None
    }
}

// Actor with engine context handling
#[derive(ParrotActor, Debug)]
#[ParrotActor(engine = "actix")]
pub struct EngineAwareActor {
    counter: u32,
    engine_counter: u64,
    last_operation: Option<String>,
}

impl EngineAwareActor {
    pub fn new() -> Self {
        Self {
            counter: 0,
            engine_counter: 0,
            last_operation: None,
        }
    }
    
    pub async fn handle_message(&mut self, msg: BoxedMessage, _ctx: &mut parrot::actix::ActixContext<parrot::actix::ActixActor<Self>>) 
        -> ActorResult<BoxedMessage> {
        match_message!(self, msg,
            Increment => |actor: &mut Self, inc: &Increment| {
                actor.counter += inc.0;
                actor.last_operation = Some("increment".to_string());
                actor.counter
            },
            GetStatus => |_: &mut Self, _: &GetStatus| {
                "regular".to_string()
            },
            Reset => |actor: &mut Self, _: &Reset| {
                actor.counter = 0;
                actor.last_operation = Some("reset".to_string());
                ()
            }
        )
    }
    
    pub fn handle_message_engine(&mut self, msg: BoxedMessage, _ctx: &mut parrot::actix::ActixContext<parrot::actix::ActixActor<Self>>, engine_ctx: NonNull<dyn Any>) -> Option<ActorResult<BoxedMessage>> {
        // Only process if we can downcast to our expected engine context type
        let engine_ctx_ref = unsafe { engine_ctx.as_ref() };
        if let Some(ctx) = engine_ctx_ref.downcast_ref::<TestEngineContext>() {
            // First check operation mode
            match ctx.mode {
                EngineMode::ErrorProne => {
                    // In error mode, always return an error
                    return Some(Err(ActorError::MessageHandlingError("Engine is in error mode".to_string())));
                },
                EngineMode::ReadOnly => {
                    // In read-only mode, only handle read operations
                    if msg.downcast_ref::<GetEngineCounter>().is_none() && 
                       msg.downcast_ref::<GetStatus>().is_none() {
                        return Some(Err(ActorError::MessageHandlingError(
                            "Engine is in read-only mode".to_string())));
                    }
                },
                EngineMode::Normal => {
                    // Normal processing continues below
                }
            }
            
            // Process different message types
            if let Some(increment) = msg.downcast_ref::<Increment>() {
                let amount = increment.0 as u64 * ctx.multiplier as u64;
                self.engine_counter += amount;
                self.last_operation = Some("engine_increment".to_string());
                return Some(Ok(Box::new(self.engine_counter) as BoxedMessage));
            } else if let Some(multiply) = msg.downcast_ref::<Multiply>() {
                if self.engine_counter == 0 {
                    self.engine_counter = 1;
                }
                self.engine_counter *= multiply.0 as u64 * ctx.multiplier as u64;
                self.last_operation = Some("engine_multiply".to_string());
                return Some(Ok(Box::new(self.engine_counter) as BoxedMessage));
            } else if let Some(_) = msg.downcast_ref::<GetEngineCounter>() {
                return Some(Ok(Box::new(self.engine_counter) as BoxedMessage));
            } else if let Some(_) = msg.downcast_ref::<Reset>() {
                self.engine_counter = 0;
                self.last_operation = Some("engine_reset".to_string());
                return Some(Ok(Box::new(()) as BoxedMessage));
            } else if let Some(_) = msg.downcast_ref::<SetMode>() {
                // SetMode is handled normally since it doesn't modify actor state
                return Some(Ok(Box::new("mode_set".to_string()) as BoxedMessage));
            } else if let Some(_) = msg.downcast_ref::<InvalidOperation>() {
                return Some(Err(ActorError::MessageHandlingError("Invalid operation requested".to_string())));
            }
        }
        
        None // Fall back to regular message handling
    }
}

// ==================== Manual Actor Implementation (for comparison) ====================

// Here we manually implement an Actor, for comparison with the macro-generated code
pub struct ManualActor {
    pub counter: u32,
}

impl ManualActor {
    pub fn new() -> Self {
        ManualActor { counter: 0 }
    }
}

impl Actor for ManualActor {
    type Config = EmptyConfig;
    type Context = parrot::actix::ActixContext;
    
    fn receive_message<'a>(&'a mut self, msg: BoxedMessage, _ctx: &'a mut Self::Context) 
        -> BoxedFuture<'a, ActorResult<BoxedMessage>> {
        Box::pin(async move {
            if let Some(increment) = msg.downcast_ref::<Increment>() {
                self.counter += increment.0;
                return Ok(Box::new(self.counter) as Box<dyn Any + Send>);
            }
            
            if let Some(_) = msg.downcast_ref::<GetStatus>() {
                return Ok(Box::new("manual".to_string()) as Box<dyn Any + Send>);
            }
            
            if let Some(counter_msg) = msg.downcast_ref::<CounterMsg>() {
                self.counter += counter_msg.0;
                return Ok(Box::new(self.counter) as Box<dyn Any + Send>);
            }
            
            Err(ActorError::MessageHandlingError("Unknown message type".to_string()))
        })
    }
    
    fn receive_message_with_engine<'a>(&'a mut self, msg: BoxedMessage, _ctx: &'a mut Self::Context, _engine_ctx: NonNull<dyn Any>) -> Option<ActorResult<BoxedMessage>> {
        None
    }
    
    fn state(&self) -> ActorState {
        ActorState::Running
    }
}

// ==================== Test Cases ====================

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_default_actor() {
        let actor = DefaultActor { counter: 0 };
        
        // Confirm Actor trait implementation
        assert_eq!(actor.state(), ActorState::Running);
    }
    
    #[test]
    fn test_string_engine_actor() {
        let actor = StringEngineActor { counter: 0 };
        
        // Confirm Actor trait implementation
        assert_eq!(actor.state(), ActorState::Running);
    }
    
    #[test]
    fn test_constant_engine_actor() {
        let actor = ConstantEngineActor { counter: 0 };
        
        // Confirm Actor trait implementation
        assert_eq!(actor.state(), ActorState::Running);
    }
    
    #[test]
    fn test_complex_config_actor() {
        let actor = ComplexConfigActor { 
            counter: 0,
            config: MyConfig { timeout: 10 }
        };
        
        // Confirm Actor trait implementation
        assert_eq!(actor.state(), ActorState::Running);
        
        // Validate configuration type
        let config = MyConfig { timeout: 10 };
        assert_eq!(config.timeout, 10);
    }
    
    #[test]
    fn test_generic_actor() {
        let actor = GenericActor { 
            value: "test_data".to_string(),
        };
        
        // Confirm Actor trait implementation
        assert_eq!(actor.state(), ActorState::Running);
    }
    
    #[test]
    fn test_simple_actor() {
        let actor = SimpleActor::new();
        
        // Confirm Actor trait implementation
        assert_eq!(actor.state(), ActorState::Running);
    }
    
    #[tokio::test]
    async fn test_message_handling() {
        let mut actor = DefaultActor { counter: 0 };
        let mut ctx = parrot::actix::ActixContext::<parrot::actix::ActixActor<DefaultActor>>::default();
        
        // Test Increment message
        let result = actor.receive_message(Box::new(Increment(5)), &mut ctx).await;
        assert!(result.is_ok());
        if let Ok(boxed) = result {
            let value: u32 = *boxed.downcast::<u32>().unwrap();
            assert_eq!(value, 5);
        }
        
        // Test GetStatus message
        let result = actor.receive_message(Box::new(GetStatus), &mut ctx).await;
        assert!(result.is_ok());
        if let Ok(boxed) = result {
            let value: String = *boxed.downcast::<String>().unwrap();
            assert_eq!(value, "default");
        }
        
        // Test Reset message
        actor.counter = 10; // Set a value first
        let result = actor.receive_message(Box::new(Reset), &mut ctx).await;
        assert!(result.is_ok());
        assert_eq!(actor.counter, 0);
        
        // Test ComplexMessage (success case)
        let complex_msg = ComplexMessage {
            succeed: true,
            data: "success".to_string()
        };
        let result = actor.receive_message(Box::new(complex_msg), &mut ctx).await;
        assert!(result.is_ok());
        if let Ok(boxed) = result {
            let value: Result<String, String> = *boxed.downcast::<Result<String, String>>().unwrap();
            assert_eq!(value.unwrap(), "success");
        }
        
        // Test ComplexMessage (failure case)
        let complex_msg = ComplexMessage {
            succeed: false,
            data: "will fail".to_string()
        };
        let result = actor.receive_message(Box::new(complex_msg), &mut ctx).await;
        assert!(result.is_ok());
        if let Ok(boxed) = result {
            let value: Result<String, String> = *boxed.downcast::<Result<String, String>>().unwrap();
            match value {
                Ok(_) => panic!("Expected Err, got Ok"),
                Err(err) => assert_eq!(err, "Failed operation"),
            }
        }
        
        // Test unknown message type
        let result = actor.receive_message(Box::new(UnknownMessage), &mut ctx).await;
        assert!(result.is_err());
        match result {
            Err(ActorError::MessageHandlingError(_)) => {},
            _ => panic!("Expected MessageHandlingError"),
        }
    }
    
    #[tokio::test]
    async fn test_simple_actor_message_handling() {
        let mut actor = SimpleActor::new();
        let mut ctx = parrot::actix::ActixContext::<parrot::actix::ActixActor<SimpleActor>>::default();
        
        // Test CounterMsg
        let result = actor.receive_message(Box::new(CounterMsg(5)), &mut ctx).await;
        assert!(result.is_ok(), "Message handling failed");
        
        if let Ok(boxed) = result {
            let value: u32 = *boxed.downcast::<u32>().unwrap();
            assert_eq!(value, 5, "Counter should be incremented to 5");
        }
    }
    
    #[tokio::test]
    async fn test_generic_actor_message_handling() {
        let mut actor = GenericActor { 
            value: vec![1, 2, 3],
        };
        let mut ctx = parrot::actix::ActixContext::<parrot::actix::ActixActor<GenericActor<Vec<i32>>>>::default();
        
        // Test Increment message
        let result = actor.receive_message(Box::new(Increment(5)), &mut ctx).await;
        assert!(result.is_ok());
        if let Ok(boxed) = result {
            let value: Vec<i32> = *boxed.downcast::<Vec<i32>>().unwrap();
            assert_eq!(value, vec![1, 2, 3, 5]);
        }
        
        // Test GetStatus message
        let result = actor.receive_message(Box::new(GetStatus), &mut ctx).await;
        assert!(result.is_ok());
        if let Ok(boxed) = result {
            let value: String = *boxed.downcast::<String>().unwrap();
            assert_eq!(value, "[1, 2, 3, 5]");
        }
    }
    
    #[tokio::test]
    async fn test_manual_vs_derived_actor() {
        let mut manual_actor = ManualActor::new();
        let mut derived_actor = DefaultActor { counter: 0 };
        let mut ctx_manual = parrot::actix::ActixContext::<()>::default();
        let mut ctx_derived = parrot::actix::ActixContext::<parrot::actix::ActixActor<DefaultActor>>::default();
        
        // Test whether implementations are consistent
        let manual_result = manual_actor.receive_message(Box::new(Increment(5)), &mut ctx_manual).await;
        let derived_result = derived_actor.receive_message(Box::new(Increment(5)), &mut ctx_derived).await;
        
        assert!(manual_result.is_ok());
        assert!(derived_result.is_ok());
        
        if let (Ok(manual_boxed), Ok(derived_boxed)) = (manual_result, derived_result) {
            let manual_value: u32 = *manual_boxed.downcast::<u32>().unwrap();
            let derived_value: u32 = *derived_boxed.downcast::<u32>().unwrap();
            
            assert_eq!(manual_value, derived_value);
            assert_eq!(manual_value, 5);
        }
    }
    
    #[tokio::test]
    async fn test_simple_vs_manual_actor() {
        let mut manual = ManualActor::new();
        let mut simple = SimpleActor::new();
        let mut ctx_manual = parrot::actix::ActixContext::<()>::default();
        let mut ctx_simple = parrot::actix::ActixContext::<parrot::actix::ActixActor<SimpleActor>>::default();
        
        // Test whether implementations are consistent
        let manual_result = manual.receive_message(Box::new(CounterMsg(10)), &mut ctx_manual).await;
        let simple_result = simple.receive_message(Box::new(CounterMsg(10)), &mut ctx_simple).await;
        
        assert!(manual_result.is_ok() && simple_result.is_ok(), "Both should succeed");
        
        if let (Ok(manual_box), Ok(simple_box)) = (manual_result, simple_result) {
            let manual_val: u32 = *manual_box.downcast::<u32>().unwrap();
            let simple_val: u32 = *simple_box.downcast::<u32>().unwrap();
            
            assert_eq!(manual_val, 10, "Manual actor should have counter=10");
            assert_eq!(simple_val, 10, "Simple actor should have counter=10");
            assert_eq!(manual_val, simple_val, "Both implementations should behave identically");
        }
    }

    #[tokio::test]
    async fn test_receive_message_with_engine() {
        // Create actor instances for testing
        let mut derived_actor = DefaultActor { counter: 0 };
        let mut manual_actor = ManualActor::new();
        let mut ctx_derived = parrot::actix::ActixContext::<parrot::actix::ActixActor<DefaultActor>>::default();
        let mut ctx_manual = parrot::actix::ActixContext::<()>::default();
        
        // Create engine context data
        let engine_data = 42u32;
        let engine_ctx = unsafe { NonNull::new_unchecked(Box::into_raw(Box::new(engine_data) as Box<dyn Any>)) };
        
        // Prepare a test message
        let increment_msg = Box::new(Increment(5)) as BoxedMessage;
        
        // Test the derive macro's receive_message_with_engine implementation
        let derived_result = derived_actor.receive_message_with_engine(increment_msg, &mut ctx_derived, engine_ctx);
        
        // Create a new message since the previous one was moved
        let increment_msg2 = Box::new(Increment(5)) as BoxedMessage;
        
        // Test the manually implemented receive_message_with_engine
        let manual_result = manual_actor.receive_message_with_engine(increment_msg2, &mut ctx_manual, engine_ctx);
        
        // Both should return None (default behavior)
        assert!(derived_result.is_none(), "ParrotActor derive macro's receive_message_with_engine should return None");
        assert!(manual_result.is_none(), "Manually implemented receive_message_with_engine should return None");
        
        // Ensure normal message handling still works
        let normal_msg = Box::new(Increment(7)) as BoxedMessage;
        let normal_result = derived_actor.receive_message(normal_msg, &mut ctx_derived).await;
        assert!(normal_result.is_ok());
        assert_eq!(derived_actor.counter, 7);
        
        // Clean up raw pointer
        unsafe {
            let _ = Box::from_raw(engine_ctx.as_ptr());
        }
    }
    
    #[tokio::test]
    async fn test_receive_message_with_engine_all_types() {
        // Create instances of all actor types
        let mut default_actor = DefaultActor { counter: 0 };
        let mut string_engine_actor = StringEngineActor { counter: 0 };
        let mut constant_engine_actor = ConstantEngineActor { counter: 0 };
        let mut complex_config_actor = ComplexConfigActor { 
            counter: 0,
            config: MyConfig { timeout: 10 }
        };
        let mut simple_actor = SimpleActor::new();
        let mut generic_actor = GenericActor { value: vec![1, 2, 3] };
        
        let mut ctx_default = parrot::actix::ActixContext::<parrot::actix::ActixActor<DefaultActor>>::default();
        let mut ctx_string = parrot::actix::ActixContext::<parrot::actix::ActixActor<StringEngineActor>>::default();
        let mut ctx_constant = parrot::actix::ActixContext::<parrot::actix::ActixActor<ConstantEngineActor>>::default();
        let mut ctx_complex = parrot::actix::ActixContext::<parrot::actix::ActixActor<ComplexConfigActor>>::default();
        let mut ctx_simple = parrot::actix::ActixContext::<parrot::actix::ActixActor<SimpleActor>>::default();
        let mut ctx_generic = parrot::actix::ActixContext::<parrot::actix::ActixActor<GenericActor<Vec<i32>>>>::default();
        
        // Create engine context data
        let engine_data = 42u32;
        let engine_ctx = unsafe { NonNull::new_unchecked(Box::into_raw(Box::new(engine_data) as Box<dyn Any>)) };
        
        // Test receive_message_with_engine for each actor
        let default_result = default_actor.receive_message_with_engine(Box::new(Increment(5)) as BoxedMessage, &mut ctx_default, engine_ctx);
        let string_result = string_engine_actor.receive_message_with_engine(Box::new(Increment(5)) as BoxedMessage, &mut ctx_string, engine_ctx);
        let constant_result = constant_engine_actor.receive_message_with_engine(Box::new(Increment(5)) as BoxedMessage, &mut ctx_constant, engine_ctx);
        let complex_result = complex_config_actor.receive_message_with_engine(Box::new(Increment(5)) as BoxedMessage, &mut ctx_complex, engine_ctx);
        let simple_result = simple_actor.receive_message_with_engine(Box::new(Increment(5)) as BoxedMessage, &mut ctx_simple, engine_ctx);
        let generic_result = generic_actor.receive_message_with_engine(Box::new(Increment(5)) as BoxedMessage, &mut ctx_generic, engine_ctx);
        
        // All derived actors should return None
        assert!(default_result.is_none(), "DefaultActor's receive_message_with_engine should return None");
        assert!(string_result.is_none(), "StringEngineActor's receive_message_with_engine should return None");
        assert!(constant_result.is_none(), "ConstantEngineActor's receive_message_with_engine should return None");
        assert!(complex_result.is_none(), "ComplexConfigActor's receive_message_with_engine should return None");
        assert!(simple_result.is_none(), "SimpleActor's receive_message_with_engine should return None");
        assert!(generic_result.is_none(), "GenericActor's receive_message_with_engine should return None");
        
        // Clean up raw pointer
        unsafe {
            let _ = Box::from_raw(engine_ctx.as_ptr());
        }
    }

    // Tests for engine message handling using handle_message_engine
    #[tokio::test]
    async fn test_handle_message_engine() {
        // Create engine-aware actor
        let mut actor = EngineAwareActor::new();
        let mut ctx = parrot::actix::ActixContext::<parrot::actix::ActixActor<EngineAwareActor>>::default();
        
        // Create normal mode engine context
        let engine_ctx = TestEngineContext {
            multiplier: 2,
            mode: EngineMode::Normal,
        };
        let engine_ptr = unsafe { NonNull::new_unchecked(Box::into_raw(Box::new(engine_ctx) as Box<dyn Any>)) };
        
        // Test Increment with engine context
        let result = actor.receive_message_with_engine(Box::new(Increment(5)) as BoxedMessage, &mut ctx, engine_ptr);
        assert!(result.is_some(), "Should handle the message with engine context");
        
        if let Some(Ok(boxed)) = result {
            let value = boxed.downcast::<u64>().unwrap();
            assert_eq!(*value, 10); // 5 * 2 = 10
            assert_eq!(actor.engine_counter, 10);
            assert_eq!(actor.last_operation, Some("engine_increment".to_string()));
        } else {
            panic!("Expected Some(Ok) result for increment with engine");
        }
        
        // Test Multiply with engine context
        let result = actor.receive_message_with_engine(Box::new(Multiply(3)) as BoxedMessage, 
                                                     &mut ctx, engine_ptr);
        assert!(result.is_some());
        
        if let Some(Ok(boxed)) = result {
            let value = boxed.downcast::<u64>().unwrap();
            assert_eq!(*value, 60); // 10 * 3 * 2 = 60
            assert_eq!(actor.engine_counter, 60);
            assert_eq!(actor.last_operation, Some("engine_multiply".to_string()));
        } else {
            panic!("Expected Some(Ok) result for multiply with engine");
        }
        
        // Test GetEngineCounter
        let result = actor.receive_message_with_engine(Box::new(GetEngineCounter) as BoxedMessage, 
                                                     &mut ctx, engine_ptr);
        assert!(result.is_some());
        
        if let Some(Ok(boxed)) = result {
            let value = boxed.downcast::<u64>().unwrap();
            assert_eq!(*value, 60);
        } else {
            panic!("Expected Some(Ok) result for get engine counter");
        }
        
        // Test Reset
        let result = actor.receive_message_with_engine(Box::new(Reset) as BoxedMessage, 
                                                     &mut ctx, engine_ptr);
        assert!(result.is_some());
        
        if let Some(Ok(_)) = result {
            assert_eq!(actor.engine_counter, 0);
            assert_eq!(actor.last_operation, Some("engine_reset".to_string()));
        } else {
            panic!("Expected Some(Ok) result for reset with engine");
        }
        
        // Clean up raw pointer
        unsafe {
            let _ = Box::from_raw(engine_ptr.as_ptr());
        }
    }
    
    #[tokio::test]
    async fn test_handle_message_engine_readonly_mode() {
        // Create engine-aware actor
        let mut actor = EngineAwareActor::new();
        let mut ctx = parrot::actix::ActixContext::<parrot::actix::ActixActor<EngineAwareActor>>::default();
        
        // Set initial counter value for testing
        actor.engine_counter = 100;
        
        // Create read-only mode engine context
        let engine_ctx = TestEngineContext {
            multiplier: 2,
            mode: EngineMode::ReadOnly,
        };
        let engine_ptr = unsafe { NonNull::new_unchecked(Box::into_raw(Box::new(engine_ctx) as Box<dyn Any>)) };
        
        // Test read operation (should succeed)
        let result = actor.receive_message_with_engine(Box::new(GetEngineCounter) as BoxedMessage, 
                                                     &mut ctx, engine_ptr);
        assert!(result.is_some());
        
        if let Some(Ok(boxed)) = result {
            let value = boxed.downcast::<u64>().unwrap();
            assert_eq!(*value, 100);
        } else {
            panic!("Expected Some(Ok) result for read operation in readonly mode");
        }
        
        // Test write operation (should fail)
        let result = actor.receive_message_with_engine(Box::new(Increment(5)) as BoxedMessage, 
                                                     &mut ctx, engine_ptr);
        assert!(result.is_some());
        
        if let Some(Err(ActorError::MessageHandlingError(msg))) = result {
            assert_eq!(msg, "Engine is in read-only mode");
            assert_eq!(actor.engine_counter, 100); // Should not change
        } else {
            panic!("Expected Some(Err) result for write operation in readonly mode");
        }
        
        // Clean up raw pointer
        unsafe {
            let _ = Box::from_raw(engine_ptr.as_ptr());
        }
    }
    
    #[tokio::test]
    async fn test_handle_message_engine_error_mode() {
        // Create engine-aware actor
        let mut actor = EngineAwareActor::new();
        let mut ctx = parrot::actix::ActixContext::<parrot::actix::ActixActor<EngineAwareActor>>::default();
        
        // Create error-prone mode engine context
        let engine_ctx = TestEngineContext {
            multiplier: 2,
            mode: EngineMode::ErrorProne,
        };
        let engine_ptr = unsafe { NonNull::new_unchecked(Box::into_raw(Box::new(engine_ctx) as Box<dyn Any>)) };
        
        // Test different message types - all should fail
        let messages = [
            Box::new(Increment(5)) as BoxedMessage,
            Box::new(Multiply(3)) as BoxedMessage,
            Box::new(GetEngineCounter) as BoxedMessage,
            Box::new(Reset) as BoxedMessage,
        ];
        
        for (i, msg) in messages.iter().enumerate() {
            // Clone the message content
            let message: BoxedMessage = match i {
                0 => Box::new(Increment(5)),
                1 => Box::new(Multiply(3)),
                2 => Box::new(GetEngineCounter),
                3 => Box::new(Reset),
                _ => unreachable!(),
            };
            
            let result = actor.receive_message_with_engine(message, &mut ctx, engine_ptr);
            assert!(result.is_some(), "Message {} should be handled", i);
            
            if let Some(Err(ActorError::MessageHandlingError(msg))) = result {
                assert_eq!(msg, "Engine is in error mode");
            } else {
                panic!("Expected Some(Err) for message {} in error mode", i);
            }
        }
        
        // Clean up raw pointer
        unsafe {
            let _ = Box::from_raw(engine_ptr.as_ptr());
        }
    }
    
    #[tokio::test]
    async fn test_handle_message_engine_invalid_operation() {
        // Create engine-aware actor
        let mut actor = EngineAwareActor::new();
        let mut ctx = parrot::actix::ActixContext::<parrot::actix::ActixActor<EngineAwareActor>>::default();
        
        // Create normal mode engine context
        let engine_ctx = TestEngineContext {
            multiplier: 2,
            mode: EngineMode::Normal,
        };
        let engine_ptr = unsafe { NonNull::new_unchecked(Box::into_raw(Box::new(engine_ctx) as Box<dyn Any>)) };
        
        // Test invalid operation
        let result = actor.receive_message_with_engine(Box::new(InvalidOperation) as BoxedMessage, 
                                                     &mut ctx, engine_ptr);
        assert!(result.is_some());
        
        if let Some(Err(ActorError::MessageHandlingError(msg))) = result {
            assert_eq!(msg, "Invalid operation requested");
        } else {
            panic!("Expected Some(Err) result for invalid operation");
        }
        
        // Clean up raw pointer
        unsafe {
            let _ = Box::from_raw(engine_ptr.as_ptr());
        }
    }
    
    #[tokio::test]
    async fn test_handle_message_engine_fallback() {
        // Create engine-aware actor
        let mut actor = EngineAwareActor::new();
        let mut ctx = parrot::actix::ActixContext::<parrot::actix::ActixActor<EngineAwareActor>>::default();
        
        // Create an incompatible engine context type
        let wrong_ctx = 42u32;
        let engine_ptr = unsafe { NonNull::new_unchecked(Box::into_raw(Box::new(wrong_ctx) as Box<dyn Any>)) };
        
        // Should fall back to regular message handling
        let result = actor.receive_message_with_engine(Box::new(Increment(5)) as BoxedMessage, 
                                                     &mut ctx, engine_ptr);
        assert!(result.is_none(), "Should return None for fallback with incompatible context");
        
        // Test that regular message handling still works
        let normal_result = actor.receive_message(Box::new(Increment(5)) as BoxedMessage, &mut ctx).await;
        assert!(normal_result.is_ok());
        assert_eq!(actor.counter, 5);
        assert_eq!(actor.engine_counter, 0); // Unchanged
        assert_eq!(actor.last_operation, Some("increment".to_string()));
        
        // Clean up raw pointer
        unsafe {
            let _ = Box::from_raw(engine_ptr.as_ptr());
        }
    }
    
    #[tokio::test]
    async fn test_handle_message_engine_sequential_operations() {
        // Create engine-aware actor
        let mut actor = EngineAwareActor::new();
        let mut ctx = parrot::actix::ActixContext::<parrot::actix::ActixActor<EngineAwareActor>>::default();
        
        // Create normal mode engine context
        let engine_ctx = TestEngineContext {
            multiplier: 2,
            mode: EngineMode::Normal,
        };
        let engine_ptr = unsafe { NonNull::new_unchecked(Box::into_raw(Box::new(engine_ctx) as Box<dyn Any>)) };
        
        // Define sequence of operations and expected values
        let operations = [
            (0, Box::new(Increment(10)) as BoxedMessage, 20), // 0 + (10*2) = 20
            (1, Box::new(Multiply(3)) as BoxedMessage, 120),  // 20 * (3*2) = 120
            (2, Box::new(GetEngineCounter) as BoxedMessage, 120), // Still 120
            (3, Box::new(Reset) as BoxedMessage, 0),          // Reset to 0
            (4, Box::new(Increment(15)) as BoxedMessage, 30), // 0 + (15*2) = 30
        ];
        
        for (i, message, expected) in operations.iter() {
            // Create a new message for each operation
            let msg: BoxedMessage = match i {
                0 => Box::new(Increment(10)),
                1 => Box::new(Multiply(3)),
                2 => Box::new(GetEngineCounter),
                3 => Box::new(Reset),
                4 => Box::new(Increment(15)),
                _ => unreachable!(),
            };
            
            let result = actor.receive_message_with_engine(msg, &mut ctx, engine_ptr);
            assert!(result.is_some(), "Operation {} should return Some", i);
            
            match result {
                Some(Ok(boxed)) => {
                    if *i != 3 { // Skip Reset (returns unit)
                        let value = boxed.downcast::<u64>().unwrap_or_else(|_| 
                            panic!("Expected u64 value for operation {}", i)
                        );
                        assert_eq!(*value, *expected as u64, 
                                 "Operation {} should return {}", i, expected);
                    }
                },
                Some(Err(e)) => panic!("Operation {} failed: {:?}", i, e),
                None => panic!("Operation {} returned None", i),
            }
            
            // Verify engine counter
            assert_eq!(actor.engine_counter, *expected as u64, 
                     "Engine counter should be {} after operation {}", expected, i);
        }
        
        // Clean up raw pointer
        unsafe {
            let _ = Box::from_raw(engine_ptr.as_ptr());
        }
    }
}