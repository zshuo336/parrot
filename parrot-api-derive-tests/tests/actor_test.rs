use parrot_api::actor::{Actor, ActorConfig, ActorState, EmptyConfig};
use parrot_api::message::Message;
use parrot_api::types::{BoxedMessage, ActorResult, BoxedFuture};
use parrot_api::errors::ActorError;
use parrot_api_derive::{Message, ParrotActor};
use parrot_api::{match_message, message_response_ok};

use std::fmt::Debug;
use std::any::Any;

// Constants for engine selection
pub const ACTIX: &str = "actix";
pub const TOKIO: &str = "tokio";

// Create a mock module to mimic parrot::actix module
pub mod parrot {
    pub mod actix {
        // Mock ActixContext for testing
        pub struct ActixContext<A = ()> {
            _phantom: std::marker::PhantomData<A>,
        }
        
        impl<A> Default for ActixContext<A> {
            fn default() -> Self {
                ActixContext {
                    _phantom: std::marker::PhantomData,
                }
            }
        }
        
        // Mock ActorBase for testing
        pub struct ActorBase<A> {
            actor: A,
        }
        
        impl<A> ActorBase<A> {
            pub fn new(actor: A) -> Self {
                ActorBase { actor }
            }
        }
        
        // Mock trait for testing
        pub trait IntoActorBase {
            fn into_actor_base(self) -> ActorBase<Self> where Self: Sized;
        }
    }
}

// Custom configuration type
#[derive(Debug, Default)]
pub struct MyConfig {
    pub timeout: u64,
}
impl ActorConfig for MyConfig {}

// Define messages for testing
#[derive(Message, Clone, Debug)]
#[message(result = "u32")]
pub struct Increment(pub u32);

#[derive(Message, Clone, Debug)]
#[message(result = "String")]
pub struct GetStatus;

#[derive(Message, Clone, Debug)]
#[message(result = "()")]
pub struct Reset;

// For testing unknown message types
#[derive(Clone, Debug)]
pub struct UnknownMessage;

// Test multiple return types
#[derive(Message, Clone, Debug)]
#[message(result = "Result<String, String>")]
pub struct ComplexMessage {
    pub succeed: bool,
    pub data: String,
}

// Simple counter message from simplified test
#[derive(Message, Clone, Debug)]
#[message(result = "u32")]
pub struct CounterMsg(pub u32);

// ==================== Actor Implementations ====================

// 1. Using default engine (actix), explicitly specifying EmptyConfig
#[derive(ParrotActor, Debug)]
#[ParrotActor(engine = "actix")]
pub struct DefaultActor {
    counter: u32,
}

// Add handle_message method to support code generated by ParrotActor macro
impl DefaultActor {

    pub async fn handle_message(&mut self, msg: BoxedMessage, _ctx: &mut parrot::actix::ActixContext) 
        -> ActorResult<BoxedMessage> {
        match_message!(self, msg,
            Increment => |actor: &mut Self, inc: &Increment| {
                actor.counter += inc.0;
                actor.counter
            },
            GetStatus => |_: &mut Self, _: &GetStatus| {
                "default".to_string()
            },
            Reset => |actor: &mut Self, _: &Reset| {
                actor.counter = 0;
                ()
            },
            ComplexMessage => |_: &mut Self, complex: &ComplexMessage| {
                if complex.succeed {
                    Ok::<String, String>(complex.data.clone())
                } else {
                    Err::<String, String>("Failed operation".to_string())
                }
            }
        )
    }
}

// 2. Using string to specify engine
#[derive(ParrotActor, Debug)]
#[ParrotActor(engine = "actix")]
pub struct StringEngineActor {
    counter: u32,
}

// Add handle_message method
impl StringEngineActor {
    pub async fn handle_message(&mut self, msg: BoxedMessage, _ctx: &mut parrot::actix::ActixContext) 
        -> ActorResult<BoxedMessage> {
        if let Some(increment) = msg.downcast_ref::<Increment>() {
            self.counter += increment.0;
            return message_response_ok!(Increment, self.counter);
        }
        
        if let Some(_) = msg.downcast_ref::<GetStatus>() {
            return message_response_ok!(GetStatus, "string_engine".to_string());
        }
        
        Err(ActorError::MessageHandlingError("Unknown message type".to_string()))
    }
}

// 3. Using constant to specify engine
#[derive(ParrotActor, Debug)]
#[ParrotActor(engine = "actix")]
pub struct ConstantEngineActor {
    counter: u32,
}

// Add handle_message method
impl ConstantEngineActor {
    pub async fn handle_message(&mut self, msg: BoxedMessage, _ctx: &mut parrot::actix::ActixContext) 
        -> ActorResult<BoxedMessage> {
        if let Some(increment) = msg.downcast_ref::<Increment>() {
            self.counter += increment.0;
            return Ok(Box::new(self.counter) as Box<dyn Any + Send>);
        }
        
        if let Some(_) = msg.downcast_ref::<GetStatus>() {
            return Ok(Box::new("constant_engine".to_string()) as Box<dyn Any + Send>);
        }
        
        Err(ActorError::MessageHandlingError("Unknown message type".to_string()))
    }
}

// 4. Using full configuration parameters, specifying MyConfig as configuration type
#[derive(ParrotActor, Debug)]
#[ParrotActor(engine = "actix", config = "MyConfig")]
pub struct ComplexConfigActor {
    counter: u32,
    config: MyConfig,
}

// Add handle_message method
impl ComplexConfigActor {
    pub async fn handle_message(&mut self, msg: BoxedMessage, _ctx: &mut parrot::actix::ActixContext) 
        -> ActorResult<BoxedMessage> {
        if let Some(increment) = msg.downcast_ref::<Increment>() {
            self.counter += increment.0;
            return Ok(Box::new(self.counter) as Box<dyn Any + Send>);
        }
        
        if let Some(_) = msg.downcast_ref::<GetStatus>() {
            return Ok(Box::new(self.config.timeout.to_string()) as Box<dyn Any + Send>);
        }
        
        Err(ActorError::MessageHandlingError("Unknown message type".to_string()))
    }
}

// 5. Simple actor from simplified test
#[derive(ParrotActor, Debug)]
#[ParrotActor(engine = "actix", config = "parrot_api::actor::EmptyConfig")]
pub struct SimpleActor {
    counter: u32,
}

impl SimpleActor {
    pub fn new() -> Self {
        SimpleActor { counter: 0 }
    }
    
    // Handler for ParrotActor macro
    pub async fn handle_message(&mut self, msg: BoxedMessage, _ctx: &mut parrot::actix::ActixContext) 
        -> ActorResult<BoxedMessage> {
        if let Some(counter_msg) = msg.downcast_ref::<CounterMsg>() {
            self.counter += counter_msg.0;
            return Ok(Box::new(self.counter) as Box<dyn Any + Send>);
        }
        
        Err(ActorError::MessageHandlingError("Unknown message".to_string()))
    }
}

// 6. Testing multi-level nested generic types
#[derive(ParrotActor, Debug)]
#[ParrotActor(engine = "actix", config = "parrot_api::actor::EmptyConfig")]
pub struct GenericActor<T: Debug + Clone + Send + 'static> {
    value: T,
}

// Add handle_message method
impl<T: Debug + Clone + Send + 'static> GenericActor<T> {
    pub async fn handle_message(&mut self, msg: BoxedMessage, _ctx: &mut parrot::actix::ActixContext) 
        -> ActorResult<BoxedMessage> {
        if let Some(increment) = msg.downcast_ref::<Increment>() {
            // Special handling based on T's type
            // If T is Vec<i32>, add a new element
            if let Some(vec) = ((&self.value) as &dyn Any).downcast_ref::<Vec<i32>>() {
                let mut new_vec = vec.clone();
                new_vec.push(increment.0 as i32);
                // Update self.value
                if let Some(value_any) = (Box::new(new_vec.clone()) as Box<dyn Any>).downcast::<T>().ok() {
                    self.value = *value_any;
                }
                return Ok(Box::new(new_vec) as Box<dyn Any + Send>);
            }
            // Otherwise just return a clone of the value
            return Ok(Box::new(self.value.clone()) as Box<dyn Any + Send>);
        }
        
        if let Some(_) = msg.downcast_ref::<GetStatus>() {
            return Ok(Box::new(format!("{:?}", self.value)) as Box<dyn Any + Send>);
        }
        
        if let Some(_) = msg.downcast_ref::<Reset>() {
            return Ok(Box::new("reset") as Box<dyn Any + Send>);
        }
        
        Err(ActorError::MessageHandlingError("Unknown message type".to_string()))
    }
}

// ==================== Manual Actor Implementation (for comparison) ====================

// Here we manually implement an Actor, for comparison with the macro-generated code
pub struct ManualActor {
    pub counter: u32,
}

impl ManualActor {
    pub fn new() -> Self {
        ManualActor { counter: 0 }
    }
}

impl Actor for ManualActor {
    type Config = EmptyConfig;
    type Context = parrot::actix::ActixContext;
    
    fn receive_message<'a>(&'a mut self, msg: BoxedMessage, _ctx: &'a mut Self::Context) 
        -> BoxedFuture<'a, ActorResult<BoxedMessage>> {
        Box::pin(async move {
            if let Some(increment) = msg.downcast_ref::<Increment>() {
                self.counter += increment.0;
                return Ok(Box::new(self.counter) as Box<dyn Any + Send>);
            }
            
            if let Some(_) = msg.downcast_ref::<GetStatus>() {
                return Ok(Box::new("manual".to_string()) as Box<dyn Any + Send>);
            }
            
            if let Some(counter_msg) = msg.downcast_ref::<CounterMsg>() {
                self.counter += counter_msg.0;
                return Ok(Box::new(self.counter) as Box<dyn Any + Send>);
            }
            
            Err(ActorError::MessageHandlingError("Unknown message type".to_string()))
        })
    }
    
    fn state(&self) -> ActorState {
        ActorState::Running
    }
}

// ==================== Test Cases ====================

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_default_actor() {
        let actor = DefaultActor { counter: 0 };
        
        // Confirm Actor trait implementation
        assert_eq!(actor.state(), ActorState::Running);
    }
    
    #[test]
    fn test_string_engine_actor() {
        let actor = StringEngineActor { counter: 0 };
        
        // Confirm Actor trait implementation
        assert_eq!(actor.state(), ActorState::Running);
    }
    
    #[test]
    fn test_constant_engine_actor() {
        let actor = ConstantEngineActor { counter: 0 };
        
        // Confirm Actor trait implementation
        assert_eq!(actor.state(), ActorState::Running);
    }
    
    #[test]
    fn test_complex_config_actor() {
        let actor = ComplexConfigActor { 
            counter: 0,
            config: MyConfig { timeout: 10 }
        };
        
        // Confirm Actor trait implementation
        assert_eq!(actor.state(), ActorState::Running);
        
        // Validate configuration type
        let config = MyConfig { timeout: 10 };
        assert_eq!(config.timeout, 10);
    }
    
    #[test]
    fn test_generic_actor() {
        let actor = GenericActor { 
            value: "test_data".to_string(),
        };
        
        // Confirm Actor trait implementation
        assert_eq!(actor.state(), ActorState::Running);
    }
    
    #[test]
    fn test_simple_actor() {
        let actor = SimpleActor::new();
        
        // Confirm Actor trait implementation
        assert_eq!(actor.state(), ActorState::Running);
    }
    
    #[tokio::test]
    async fn test_message_handling() {
        let mut actor = DefaultActor { counter: 0 };
        let mut ctx = parrot::actix::ActixContext::default();
        
        // Test Increment message
        let result = actor.receive_message(Box::new(Increment(5)), &mut ctx).await;
        assert!(result.is_ok());
        if let Ok(boxed) = result {
            let value: u32 = *boxed.downcast::<u32>().unwrap();
            assert_eq!(value, 5);
        }
        
        // Test GetStatus message
        let result = actor.receive_message(Box::new(GetStatus), &mut ctx).await;
        assert!(result.is_ok());
        if let Ok(boxed) = result {
            let value: String = *boxed.downcast::<String>().unwrap();
            assert_eq!(value, "default");
        }
        
        // Test Reset message
        actor.counter = 10; // Set a value first
        let result = actor.receive_message(Box::new(Reset), &mut ctx).await;
        assert!(result.is_ok());
        assert_eq!(actor.counter, 0);
        
        // Test ComplexMessage (success case)
        let complex_msg = ComplexMessage {
            succeed: true,
            data: "success".to_string()
        };
        let result = actor.receive_message(Box::new(complex_msg), &mut ctx).await;
        assert!(result.is_ok());
        if let Ok(boxed) = result {
            let value: Result<String, String> = *boxed.downcast::<Result<String, String>>().unwrap();
            assert_eq!(value.unwrap(), "success");
        }
        
        // Test ComplexMessage (failure case)
        let complex_msg = ComplexMessage {
            succeed: false,
            data: "will fail".to_string()
        };
        let result = actor.receive_message(Box::new(complex_msg), &mut ctx).await;
        assert!(result.is_ok());
        if let Ok(boxed) = result {
            let value: Result<String, String> = *boxed.downcast::<Result<String, String>>().unwrap();
            match value {
                Ok(_) => panic!("Expected Err, got Ok"),
                Err(err) => assert_eq!(err, "Failed operation"),
            }
        }
        
        // Test unknown message type
        let result = actor.receive_message(Box::new(UnknownMessage), &mut ctx).await;
        assert!(result.is_err());
        match result {
            Err(ActorError::MessageHandlingError(_)) => {},
            _ => panic!("Expected MessageHandlingError"),
        }
    }
    
    #[tokio::test]
    async fn test_simple_actor_message_handling() {
        let mut actor = SimpleActor::new();
        let mut ctx = parrot::actix::ActixContext::default();
        
        // Test CounterMsg
        let result = actor.receive_message(Box::new(CounterMsg(5)), &mut ctx).await;
        assert!(result.is_ok(), "Message handling failed");
        
        if let Ok(boxed) = result {
            let value: u32 = *boxed.downcast::<u32>().unwrap();
            assert_eq!(value, 5, "Counter should be incremented to 5");
        }
    }
    
    #[tokio::test]
    async fn test_generic_actor_message_handling() {
        let mut actor = GenericActor { 
            value: vec![1, 2, 3],
        };
        let mut ctx = parrot::actix::ActixContext::default();
        
        // Test Increment message
        let result = actor.receive_message(Box::new(Increment(5)), &mut ctx).await;
        assert!(result.is_ok());
        if let Ok(boxed) = result {
            let value: Vec<i32> = *boxed.downcast::<Vec<i32>>().unwrap();
            assert_eq!(value, vec![1, 2, 3, 5]);
        }
        
        // Test GetStatus message
        let result = actor.receive_message(Box::new(GetStatus), &mut ctx).await;
        assert!(result.is_ok());
        if let Ok(boxed) = result {
            let value: String = *boxed.downcast::<String>().unwrap();
            assert_eq!(value, "[1, 2, 3, 5]");
        }
    }
    
    #[tokio::test]
    async fn test_manual_vs_derived_actor() {
        let mut manual_actor = ManualActor::new();
        let mut derived_actor = DefaultActor { counter: 0 };
        let mut ctx = parrot::actix::ActixContext::default();
        
        // Test whether implementations are consistent
        let manual_result = manual_actor.receive_message(Box::new(Increment(5)), &mut ctx).await;
        let derived_result = derived_actor.receive_message(Box::new(Increment(5)), &mut ctx).await;
        
        assert!(manual_result.is_ok());
        assert!(derived_result.is_ok());
        
        if let (Ok(manual_boxed), Ok(derived_boxed)) = (manual_result, derived_result) {
            let manual_value: u32 = *manual_boxed.downcast::<u32>().unwrap();
            let derived_value: u32 = *derived_boxed.downcast::<u32>().unwrap();
            
            assert_eq!(manual_value, derived_value);
            assert_eq!(manual_value, 5);
        }
    }
    
    #[tokio::test]
    async fn test_simple_vs_manual_actor() {
        let mut manual = ManualActor::new();
        let mut simple = SimpleActor::new();
        let mut ctx = parrot::actix::ActixContext::default();
        
        // Test whether implementations are consistent
        let manual_result = manual.receive_message(Box::new(CounterMsg(10)), &mut ctx).await;
        let simple_result = simple.receive_message(Box::new(CounterMsg(10)), &mut ctx).await;
        
        assert!(manual_result.is_ok() && simple_result.is_ok(), "Both should succeed");
        
        if let (Ok(manual_box), Ok(simple_box)) = (manual_result, simple_result) {
            let manual_val: u32 = *manual_box.downcast::<u32>().unwrap();
            let simple_val: u32 = *simple_box.downcast::<u32>().unwrap();
            
            assert_eq!(manual_val, 10, "Manual actor should have counter=10");
            assert_eq!(simple_val, 10, "Simple actor should have counter=10");
            assert_eq!(manual_val, simple_val, "Both implementations should behave identically");
        }
    }
} 